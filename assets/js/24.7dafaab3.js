(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{343:function(t,v,_){"use strict";_.r(v);var r=_(4),a=Object(r.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"列表和队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#列表和队列"}},[t._v("#")]),t._v(" 列表和队列")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("列表或队列")]),t._v(" "),v("th",[t._v("数据结构")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("ArrayList")]),t._v(" "),v("td",[t._v("数组")]),t._v(" "),v("td",[t._v("1. 随机访问的效率高，为O(1)"),v("br"),t._v("2. 查找效率比较低，为O(N)"),v("br"),t._v("3. 添加元素的效率还可以，添加N个的效率为O(N)"),v("br"),t._v("4. 插入和删除的效率比较低，为O(N)")])]),t._v(" "),v("tr",[v("td",[t._v("LinkedList")]),t._v(" "),v("td",[t._v("双向链表")]),t._v(" "),v("td",[t._v("1. 不可以随机访问，必须从头或尾顺着链接找，效率为O(N/2)"),v("br"),t._v("2. 按内容查找的效率比较低，为O(N)"),v("br"),t._v("3. 在两端添加的效率高， 为O(1)"),v("br"),t._v("4. 在中间插入，删除元素，需要先定位，效率为O(N)，但修改本身的效率高，为O(1)")])]),t._v(" "),v("tr",[v("td",[t._v("ArrayDeque")]),t._v(" "),v("td",[t._v("循环队列")]),t._v(" "),v("td",[t._v("1. 在两端添加、删除元素的效率高，动态扩展需要的内存分配以及数组复制开销可以被平摊，添加N个元素的效率为O(N)"),v("br"),t._v("2. 根据元素内容查找和删除的效率比较低，为O(N)"),v("br"),t._v("3. 与ArrayList和LikedList不同，没有索引的概念，不能根据索引位置进行操作")])]),t._v(" "),v("tr",[v("td",[t._v("PriorityQueue")]),t._v(" "),v("td",[t._v("堆")]),t._v(" "),v("td",[t._v("1. 实现了优先级队列，最先出队的总是优先级最高的"),v("br"),t._v("2. 优先级可以相同，内部元素不是完全有序的，如果遍历输入，除了第一个，其他没有特定顺序"),v("br"),t._v("3. 查看头部的效率高，为O(1)，入队、出队的效率比较高，为O(log2(N))"),v("br"),t._v("4. 根据值查找、删除的效率比较低，为O(N)")])])])]),t._v(" "),v("h2",{attrs:{id:"map和set"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#map和set"}},[t._v("#")]),t._v(" Map和Set")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("Map")]),t._v(" "),v("th",[t._v("数据结构")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("HashMap")]),t._v(" "),v("td",[t._v("哈希表")]),t._v(" "),v("td",[t._v("1. 根据键保存和获取值的效率高，为O(1)，每个单项链表往往只有一个或几个节点，根据hash值就可以直接快速定位"),v("br"),t._v("2. HashMap中的键值对没有顺序，因为hash值是随机的")])]),t._v(" "),v("tr",[v("td",[t._v("TreeMap")]),t._v(" "),v("td",[t._v("红黑树")]),t._v(" "),v("td",[t._v("1. 按键有序，可以方便地根据键的顺序进行查找"),v("br"),t._v("2. 为了按键有序，TreeMap要求键实现Comparable接口或通过构造方法提供一个Comparator对象"),v("br"),t._v("3. 根据键保存、查找、删除的效率比较高，为O(h)，h为数的高度，在数平衡的情况下，h为log2(N)")])]),t._v(" "),v("tr",[v("td",[t._v("LinkedHashMap")]),t._v(" "),v("td",[t._v("双向链表+哈希表")]),t._v(" "),v("td",[t._v("1. 它是HashMap的子类，可以保持元素按插入或访问有序")])]),t._v(" "),v("tr",[v("td",[t._v("EnumMap")]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("1. 键的类型为枚举类型")])])])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("Set")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("HashSet")]),t._v(" "),v("td",[t._v("1. 没有重复元素，没有顺序"),v("br"),t._v("2. 添加、删除、判断元素是否存在，效率都为O(1)")])]),t._v(" "),v("tr",[v("td",[t._v("TreeSet")]),t._v(" "),v("td",[t._v("1. 没有重复元素，没有顺序"),v("br"),t._v("2. 添加、删除、判断元素是否存在，效率都为O(log2(N))"),v("br"),t._v("3. 有序，可以方便地根据键的顺序进行查找"),v("br"),t._v("4. 为了有序，TreeSet要求键实现Comparable接口或通过构造方法提供一个Comparator对象")])]),t._v(" "),v("tr",[v("td",[t._v("EnumSet")]),t._v(" "),v("td",[t._v("1. 基于位向量，效率高")])])])])])}),[],!1,null,null,null);v.default=a.exports}}]);